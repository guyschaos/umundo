package umundo;

option java_package = "org.umundo.ser";
option java_outer_classname = "UMMessageProtos";

/*! {\brief {Defines the format of messages in umundo.}} 
    
    This proto defines the the format of messages in uMundo. It contains
    standard messages for strings, booleans, int (signed int32), longs, floats and
    doubles. You can think of these messages as arbitrarily sized arrays (or lists)
    of the specific type. Plus there is a general message {\p UM_message}, that
    consists of all of these messages as optional parts. uMundo messages are sent
    around using these {\p UM_messages}. For example, if a string should be sent
    around, you would create a {\p UM_string_message} and place it inside the {\p
    UM_message} that goes on the wire.

    Protobuf cannot distinguish between different message types by relying purely 
    on their binary representation. Therefore, only messages of the type {\p
    UM_message} are used in uMundo. Supplying user messages then would require
    using the magic number indicating a binary message. However, to avoid this 
    problem, the extensions construct in protobuf is used in {\p UM_message}. This
    means, that custom messages can define an extension to {\p UM_message},
    specifying additional components. {\p UM_message} allows the tag range 
    {\code 16 to max\endcode} for user extensions.

    If a message transporting a custom message of a certain type is needed, this 
    can be achieved using the nested extension pattern described 
    {\link 
    http://code.google.com/intl/de-DE/apis/protocolbuffers/docs/proto.html#extensions
    here \endlink}. A generic way to achieve this is to use the {\p
    UM_typed_message}. This special message carries an embedded message and a
    string component describing the type of that message.
    
    {\note Note that using the convenient {\p UM_typed_message} comes at a cost:
    the on wire size of the message becomes bloated by the type identifier. In
    case of performance critical applications, the denser {\p UM_message} or a
    binary payload should be used}

    In order to generate the sources to use this description, you hava to invoke
    {\p protoc} with appropriate parameters for the target source. See the 
    protobuf description for details: {\link http://code.google.com/p/protobuf/}.

    {@author	Felix Heinrichs <felix.heinrichs@cs.tu-darmstadt.de>}
*/

message UMStringMessage {
    repeated string payload = 1;
}

message UMIntMessage {
    repeated int32 payload = 1;
}

message UMLongMessage {
    repeated int64 payload = 1;
}

message UMBoolMessage {
    repeated bool payload = 1;
}

message UMFloatMessage {
    repeated float payload = 1;
}

message UMDoubleMessage {
    repeated double payload = 1;
}

message UMMessage {
    optional UMStringMessage stringPayload = 1;
    optional UMIntMessage intPayload = 2;
    optional UMLongMessage longPayload = 3;
    optional UMBoolMessage boolPayload = 4;
    optional UMFloatMessage floatPayload = 5;
    optional UMDoubleMessage doublePayload = 6;

    extensions 15 to max;
}
