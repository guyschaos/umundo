#include "thread/pthread/Thread.h"

namespace umundo {

Thread::Thread() {
	DEBUG_CTOR("Thread");
	_isStarted = false;
}

Thread::~Thread() {
	DEBUG_DTOR("Thread");
	if (_isStarted) {
		stop();
		join();
	}
}

void Thread::join() {
	int err = 0;
	err = pthread_join(_thread, NULL);
	assert(err == 0);
}

void Thread::start() {
	if (_isStarted)
		return;
	_isStarted = true;
	int err = pthread_create(&_thread, NULL, &runWrapper, (void*)this);
	assert(err == 0);
}

void* Thread::runWrapper(void *obj) {
	Thread* myself = (Thread*)obj;
	myself->run();
	return NULL;
}

void Thread::stop() {
	_isStarted = false;
}

void Thread::sleepMs(uint32_t ms) {
	usleep(1000 * ms);
}

Mutex::Mutex() {
	DEBUG_CTOR("Mutex");
	pthread_mutexattr_t attrib;
	int ret = pthread_mutexattr_init(&attrib);
	assert(ret == 0);
	ret = pthread_mutexattr_settype(&attrib, PTHREAD_MUTEX_RECURSIVE);
	assert(ret == 0);
	pthread_mutex_init(&_mutex, &attrib);
	pthread_mutexattr_destroy(&attrib);
}

Mutex::~Mutex() {
	DEBUG_DTOR("Mutex");
  pthread_mutex_destroy(&_mutex);
}

void Mutex::lock() {
	pthread_mutex_lock(&_mutex);
}

bool Mutex::tryLock() {
	if(pthread_mutex_trylock(&_mutex) == EBUSY)
		return false;
	return true;
}

void Mutex::unlock() {
	pthread_mutex_unlock(&_mutex);
}


}