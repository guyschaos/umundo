%module(directors="1", allprotected="1") umundocoreCPP
// import swig typemaps
%include <arrays_java.i>
%include <stl.i>
%include <inttypes.i>
%include "stl_set.i"
//%include "boost_shared_ptr.i"

// SWIG does not recognize 'using std::string' from an include
typedef std::string string;
typedef std::vector vector;
typedef std::set set;

%javaconst(1);

//**************************************************
// This ends up in the generated wrapper code
//**************************************************

%{
#include "../../../../core/src/umundo/common/EndPoint.h"
#include "../../../../core/src/umundo/connection/Node.h"
#include "../../../../core/src/umundo/common/Message.h"
#include "../../../../core/src/umundo/thread/Thread.h"
#include "../../../../core/src/umundo/connection/Publisher.h"
#include "../../../../core/src/umundo/connection/Subscriber.h"

#if 0
jint JNI_OnLoad(JavaVM *vm, void *reserved) {
	using umundo::Debug;
//	LOG_ERR("This is mundo.core speaking!");
	return JNI_VERSION_1_2;
}
#endif

#ifdef ANDROID
// google forgot imaxdiv in the android ndk r7 libc?!
#ifndef imaxdiv
imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom) {
	imaxdiv_t res;
	res.quot=0; res.rem=0;
	while(numer >= denom) {
		res.quot++;
		numer -= denom;
	}
	res.rem = numer;
	return res;
}
#endif
#endif

using std::string;
using std::vector;
using std::map;
using boost::shared_ptr;
using namespace umundo;
%}

# // automatically load the native library
# see http://tlrobinson.net/blog/2009/03/embedding-and-loading-a-jni-library-from-a-jar/
# see http://www.mkyong.com/java/how-to-detect-os-in-java-systemgetpropertyosname/
%pragma(java) jniclassimports=%{
import java.net.URL;
import java.util.zip.ZipFile;
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
%}

%pragma(java) jniclasscode=%{

  static {
		String libName = "libumundocoreSwig.";
    try {
				// get the class object for this class, and get the location of it
				final Class c = umundocoreCPPJNI.class;
				final URL location = c.getProtectionDomain().getCodeSource().getLocation();

				// dispatch os.type for filename
				String platformSuffix = "";
				String os = System.getProperty("os.name").toLowerCase();
				if (os.indexOf("win") >= 0) {
					platformSuffix = "dll";
				} else if(os.indexOf("mac") >= 0) {
					platformSuffix = "jnilib";				
				} else if(os.indexOf("nix") >= 0 || os.indexOf("nux") >= 0) {
					platformSuffix = "so";				
				} else if(os.indexOf("sunos") >= 0) {
      		throw new RuntimeException("Solaris not supported yet - ask me about it.");
				} else {
					throw new RuntimeException("Unknown platform " + os);
				}
				libName += platformSuffix;
				
				// jars are just zip files, get the input stream for the lib
				ZipFile zf = new ZipFile(location.getPath());
				InputStream in = zf.getInputStream(zf.getEntry(libName));

				// create a temp file and an input stream for it
				File f = File.createTempFile("JARLIB-", "-" + libName);
				FileOutputStream out = new FileOutputStream(f);

				// copy the lib to the temp file
				byte[] buf = new byte[1024];
				int len;
				while ((len = in.read(buf)) > 0)
					out.write(buf, 0, len);
				in.close();
				out.close();

				// load the lib specified by itâ€™s absolute path and delete it
				System.load(f.getAbsolutePath());
				f.delete();

    } catch (Exception e) {
      System.err.println("Native library " + libName + " failed to load in code generated by umundocore.i");
      System.err.println("Make sure the library is included in the umundocore.jar you received.");
      System.exit(1);
    }
  }
%}

//*************************************************/

// used to get all the keys in message meta information
%template(StringVector) std::vector<std::string>;
%template(PublisherSet) std::set<umundo::Publisher*>;
%template(SubcriberSet) std::set<umundo::Subscriber*>;

// allow Java classes to act as callbacks from C++
%feature("director") umundo::Receiver;
%feature("director") umundo::Connectable;
%feature("director") umundo::Greeter;

// enable conversion from char*, int to jbytearray
%apply (char *STRING, size_t LENGTH) { (const char* data, size_t length) }; 

// ignore these functions in every class
%ignore setChannelName(string);
%ignore setUUID(string);
%ignore setPort(uint16_t);
%ignore setIP(string);
%ignore setTransport(string);
%ignore setRemote(bool);
%ignore setHost(string);
%ignore setDomain(string);

// ignore class specific functions
%ignore operator!=(NodeStub* n) const;
%ignore operator<<(std::ostream&, const NodeStub*);

// rename functions
%rename(equals) operator==(NodeStub* n) const;
%rename(waitSignal) wait;

//******************************
// Prevent premature GC
//******************************

// this is helpful:
// http://stackoverflow.com/questions/9817516/swig-java-retaining-class-information-of-the-objects-bouncing-from-c

# # hold a reference to the receiver in the subscriber
# %ignore umundo::Subscriber::Subscriber(string, Receiver*);
# %typemap(javacode) umundo::Subscriber %{
#   private Receiver _receiver;
# 
#   public Subscriber(String channelName, Receiver receiver) {
#     this(umundocoreCPPJNI.new_Subscriber(channelName), true);
# 		setReceiver(receiver);
#   }
# 
#   protected void setReceiver(Receiver receiver) {
# 		_receiver = receiver;
#     umundocoreCPPJNI.Subscriber_setReceiver(swigCPtr, this, Receiver.getCPtr(receiver), receiver);
#   }
# %}
# //%typemap(javain, pre="    _receiver = $javainput;") umundo::Receiver* "$javainput"

# whenever we return a message, return a copy
%typemap(javadirectorin) umundo::Message* "(msg == 0) ? null : new Message(new Message(msg, false))"

//******************************
// Beautify Message class
//******************************

// ignore ugly std::map return
%ignore umundo::Message::getMeta();
%ignore umundo::Message::setData(string const &);
%ignore umundo::Message::Message(string);
%ignore umundo::Message::Message(string);
%rename(getData) umundo::Message::data;
%rename(getSize) umundo::Message::size;

// import java.util.HashMap
%typemap(javaimports) umundo::Message %{ 
import java.util.HashMap; 
%}

// provide convinience methods within Message Java class for meta keys
%typemap(javacode) umundo::Message %{
	public Message(Message other) {
		setData(other.getData());
		HashMap<String, String> meta = other.getMeta();
		if (meta != null)
			for (String k : meta.keySet()) {
				setMeta(k, meta.get(k));
			}
	}

	public HashMap<String, String> getMeta() {
		HashMap<String, String> keys = new HashMap<String, String>();
		for (int i = 0; i < getKeys().size(); i++) {
			keys.put(getKeys().get(i), getMeta(getKeys().get(i)));
		}
		return keys;
	}	
%}

// passing a jbytearray is done by applying the STRING, LENGTH conversion above
// but we also want to return a jbytearray to get the contents of a message.
// see: http://stackoverflow.com/questions/9934059/swig-technique-to-wrap-unsigned-binary-data

%typemap(jni) char *data "jbyteArray"
%typemap(jtype) char *data "byte[]"
%typemap(jstype) char* data "byte[]"
%typemap(javaout) char* data {
  return $jnicall;
}

%typemap(out) char *data {
  $result = JCALL1(NewByteArray, jenv, ((umundo::Message const *)arg1)->size());
  JCALL4(SetByteArrayRegion, jenv, $result, 0, ((umundo::Message const *)arg1)->size(), (jbyte *)$1);
}


//******************************
// Beautify Publisher class
//******************************

%javamethodmodifiers umundo::Subscriber::Subscriber(string channelName) "protected";
%javamethodmodifiers umundo::Subscriber::setReceiver(Receiver* receiver) "protected";

//******************************
// Beautify Connectable interface
//******************************



//******************************
// Ignore whole classes
//******************************

%ignore Implementation;
%ignore Configuration;
%ignore NodeConfig;
%ignore PublisherConfig;
%ignore SubscriberConfig;
%ignore NodeImpl;
%ignore PublisherImpl;
%ignore SubscriberImpl;
%ignore Mutex;
%ignore Thread;
%ignore Monitor;
%ignore MemoryBuffer;
%ignore ScopeLock;


//***********************************************
// Parse the header file to generate wrappers
//***********************************************

%include "../../../../core/src/umundo/common/Message.h"
%include "../../../../core/src/umundo/thread/Thread.h"
%include "../../../../core/src/umundo/common/Implementation.h"
%include "../../../../core/src/umundo/common/EndPoint.h"
%include "../../../../core/src/umundo/connection/Publisher.h"
%include "../../../../core/src/umundo/connection/Subscriber.h"
%include "../../../../core/src/umundo/connection/Node.h"

